#include <iostream>
#include <map>
#include <string>
#include <stack>
#include <utility>
#include <queue>

#include "core_cse502.h"

using namespace std;

static bool stack_has_opcode;
static bool stack_has_modrm;

struct uop
{
  bool sign_extend;
  string opcode;
  string reg1;
  string reg2;
  string immed_val;
  string disp_val;
};

void init_reg_map() 
{
  reg_map.insert(make_pair("rax", "0000"));
  reg_map.insert(make_pair("rcx", "0001"));
  reg_map.insert(make_pair("rdx", "0010"));
  reg_map.insert(make_pair("rbx", "0011"));
  reg_map.insert(make_pair("rsp", "0100"));
  reg_map.insert(make_pair("rbp", "0101"));
  reg_map.insert(make_pair("rsi", "0110"));
  reg_map.insert(make_pair("rdi", "0111"));
  reg_map.insert(make_pair("r8", "1000"));
  reg_map.insert(make_pair("r9", "1001"));
  reg_map.insert(make_pair("r10", "1010"));
  reg_map.insert(make_pair("r11", "1011"));
  reg_map.insert(make_pair("r12", "1100"));
  reg_map.insert(make_pair("r13", "1101"));
  reg_map.insert(make_pair("r14", "1110"));
  reg_map.insert(make_pair("r15", "1111"));  
}

string infer_type(sc_bv<8> instBits)
{
  switch (instBits)
    {
    case "01001000" :                                           // 0x48 - REX Prefix
    case "01001001" : return "prefix";                          // 0x49 - REX Prefix
    case "11000111" :                                           // 0xC7 - mov
    case "00110001" :                                           // 0x31 - xor
    case "10001001" :                                           // 0x89 - mov
    case "10000011" : if (stack_has_opcode && stack_has_modrm)  // 0x83 - and
	                return "immed/disp";
                      else if (stack_has_opcode) {
			stack_has_modrm = true;
			return "modrm"
                      }
                      else {
	                stack_has_opcode = true;
	                return "opcode";
                      }
    case "00001111" :        
    case "00000101" :                        // 0x0f 0x05 - syscall
    case "11111111" : return "opcode";       // 0xff - call
    default         : return "NR";
    }

  // should never come here, but just in case
  return "ERR";
}

void crack_opcodes(string opcode_list[], int num_opcodes)
{
  int i;
  struct uop *uops = new struct uop[num_opcodes];
  string prefix, opcode1, opcode2, immed_val, disp_val;
  bool gpr_64bit = false;

  for (i = 0;i < num_opcodes; i++) {
    prefix = opcode_list[i].substr(0, 8);
    if (prefix == "01001001")
      gpr_64bit = true;


  }
}

void decode(sc_bv<16*8> instBits)
{
  unsigned long tInt;
  bool oldInst = false;
  string oldInstBuf = string();
  string opcode_list[14] = { string() };
  bool inst_in_next_line = false;
  int i, j;
  string opcode_type;
  stack<string> prev_opc_type;

  stack_has_opcode = false;
  stack_has_modrm = false;
  
  for (i = 127, j= 0; i >= 0; i -= 8) {
    opcode_type = infer_type(instBits.range(i, i - 7));
    
    assert(opcode_type != "ERR");

    if (!prev_opc_type.empty()) {
      if (opcode_type == "opcode" && prev_opc_type.top() == "prefix") {
	opcode_list[j] += instBits.range(i, i - 7);
	prev_opc_type.push(opcode_type);
      }

      if (opcode_type == "modrm" && prev_opc_type.top() == "opcode") {
	opcode_list[j] += instBits.range(i, i - 7);
	prev_opc_type.push(opcode_type);
      }
      
      if (opcode_type == "opcode" && prev_opc_type.top() == "opcode") {
	opcode_list[j] += instBits.range(i, i - 7);
	prev_opc_type.push(opcode_type);
      }

      if (opcode_type == "immed/disp") {
	opcode_list[j] += instBits.range(i, i - 7);
      }
    }

    else if (!prev_opc_type.empty() && opcode_type == "prefix") {
      j++;
      prev_opc_type.empty();
      opcode_list[j] += instBits.range(i, i - 7);
      prev_opc_type.push(opcode_type);
      stack_has_opcode = false;
      stack_has_modrm = false;
    }

    else 
      opcode_list[j] += instBits.range(i, i-7);
  }

  cout<<"\nDetected opcode in stream: \n";
  for (i = 0; i < j; i++)
    cout<<opcode_list[i]<<endl;

  // uop struct initialization follow here
  crack_opcodes(opcode_list, j);
  
}
